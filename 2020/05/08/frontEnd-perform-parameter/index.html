<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="FP123456789101112FP，全称 First Paint，翻译为首次绘制,是时间线上的第一个时间点它代表网页的第一个像素渲染到屏幕上所用时间也就是页面在屏幕上首次发生视觉变化的时间performance.getEntriesByType(&amp;apos;paint&amp;apos;)function getFPTime()&amp;#123;    const timings = performance">
<meta name="keywords" content="javascript 前端">
<meta property="og:type" content="article">
<meta property="og:title" content="frontEnd perform parameter">
<meta property="og:url" content="http://jsonload.com/2020/05/08/frontEnd-perform-parameter/index.html">
<meta property="og:site_name" content="killsos">
<meta property="og:description" content="FP123456789101112FP，全称 First Paint，翻译为首次绘制,是时间线上的第一个时间点它代表网页的第一个像素渲染到屏幕上所用时间也就是页面在屏幕上首次发生视觉变化的时间performance.getEntriesByType(&amp;apos;paint&amp;apos;)function getFPTime()&amp;#123;    const timings = performance">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://jsonload.com/2020/05/08/images/render-irender-image.jpg">
<meta property="og:image" content="http://jsonload.com/2020/05/08/images/Web-Performance-Timing-API.png">
<meta property="og:updated_time" content="2020-05-09T01:24:03.547Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="frontEnd perform parameter">
<meta name="twitter:description" content="FP123456789101112FP，全称 First Paint，翻译为首次绘制,是时间线上的第一个时间点它代表网页的第一个像素渲染到屏幕上所用时间也就是页面在屏幕上首次发生视觉变化的时间performance.getEntriesByType(&amp;apos;paint&amp;apos;)function getFPTime()&amp;#123;    const timings = performance">
<meta name="twitter:image" content="http://jsonload.com/2020/05/08/images/render-irender-image.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jsonload.com/2020/05/08/frontEnd-perform-parameter/">





  <title>frontEnd perform parameter | killsos</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">killsos</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">人情似水分高下 世事如云任卷舒</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jsonload.com/2020/05/08/frontEnd-perform-parameter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="killsos.ql@gmail.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="killsos">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">frontEnd perform parameter</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-08T08:53:53+08:00">
                2020-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="FP"><a href="#FP" class="headerlink" title="FP"></a>FP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FP，全称 First Paint，翻译为首次绘制,是时间线上的第一个时间点</span><br><span class="line"></span><br><span class="line">它代表网页的第一个像素渲染到屏幕上所用时间</span><br><span class="line"></span><br><span class="line">也就是页面在屏幕上首次发生视觉变化的时间</span><br><span class="line"></span><br><span class="line">performance.getEntriesByType(&apos;paint&apos;)</span><br><span class="line"></span><br><span class="line">function getFPTime()&#123;</span><br><span class="line">    const timings = performance.getEntriesByType(&apos;paint&apos;)[0];</span><br><span class="line">    return timings ? Math.round(timings.startTime) : null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FCP"><a href="#FCP" class="headerlink" title="FCP"></a>FCP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FCP，全称 First Contentful Paint，翻译为首次内容绘制，顾名思义，它代表浏览器第一次向屏幕绘内容。</span><br><span class="line"></span><br><span class="line">注意：只有首次绘制文本、图片（包含背景图）、非白色的canvas或SVG时才被算作 FCP</span><br><span class="line"></span><br><span class="line">通过performance.getEntriesByType(&apos;paint’)，取第二个pain的时间</span><br><span class="line">或者通过Mutation Observer观察到首次节点变动的时间</span><br><span class="line"></span><br><span class="line">const domEntries = []</span><br><span class="line">const observer = new MutationObserver((mutationsList)=&gt;&#123;</span><br><span class="line">    for(var mutation of mutationsList) &#123;</span><br><span class="line">        if (mutation.type == &apos;childList&apos;) &#123;</span><br><span class="line">            console.log(&apos;A child node has been added or removed.&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mutation.type == &apos;addedNodes&apos;) &#123;</span><br><span class="line">            //TODO新增了节点，做处理，计算此时的可见性/位置/出现时间等信息，然后 push 进数组</span><br><span class="line">            domEntries.push(mutation)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function getFPTime()&#123;</span><br><span class="line">    const timings = performance.getEntriesByType(&apos;paint&apos;);</span><br><span class="line">    if(timings.length &gt; 1)return timings[1]</span><br><span class="line">    return timings ? Math.round(timings.startTime) : null</span><br><span class="line">    //伪代码,算 DOM 变化时的最小那个时间，即节点首次变动的时间</span><br><span class="line">    return Math.round(domEntries.length ? Math.min(...domEntries.map(entry =&gt; entry.time)) : 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FP与FCP这两个指标之间的主要区别是：</span><br><span class="line"></span><br><span class="line">FP是当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP。</span><br><span class="line"></span><br><span class="line">相比之下，FCP指的是浏览器首次绘制来自DOM的内容。例如：文本，图片，SVG，canvas元素等，这个时间点叫FCP。</span><br><span class="line"></span><br><span class="line">FP和FCP可能是相同的时间，也可能是先FP后FCP</span><br></pre></td></tr></table></figure>
<h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MutationObserver接口提供了监视对DOM树所做更改的能力</span><br><span class="line"></span><br><span class="line">它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分</span><br><span class="line"></span><br><span class="line">MutationObserver()</span><br><span class="line">创建并返回一个新的 MutationObserver 它会在指定的DOM发生变化时被调用</span><br></pre></td></tr></table></figure>
<h2 id="FMP"><a href="#FMP" class="headerlink" title="FMP"></a>FMP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FMP，全称 First Meaningful Paint，翻译为首次有意义的绘制</span><br><span class="line">是页面主要内容出现在屏幕上的时间, 这是用户感知加载体验的主要指标</span><br><span class="line">目前尚无标准化的定义, 因为很难以通用的方式去确定各种类型页面的关键内容</span><br><span class="line"></span><br><span class="line">目前没有统一逻辑，阿里有个标准为最高可见增量元素，采用深度优先遍历方法</span><br><span class="line">详细可见：https://zhuanlan.zhihu.com/p/44933789</span><br></pre></td></tr></table></figure>
<h2 id="FID"><a href="#FID" class="headerlink" title="FID"></a>FID</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">FID，全称 First Input Delay，翻译为首次输入延迟</span><br><span class="line">是测量用户首次与您的站点交互时的时间（即当他们单击链接/点击按钮/使用自定义的JavaScript驱动控件时）</span><br><span class="line">到浏览器实际能够回应这种互动的时间</span><br><span class="line"></span><br><span class="line">方式一，通过performanceObserver(目前支持性为88.78%)观察类型为first-input的entry，获得其startTime/duration等数即可</span><br><span class="line"></span><br><span class="line">方式二，初始化时为特定事件类型(click/touch/keydown)绑定通用统计逻辑事件</span><br><span class="line">开始调用时从event.timeStamp取开始处理的时间(这个时间就是首次输入延迟时间)</span><br><span class="line">在事件处理中注册requestIdleCallback事件回调onIdleCallback</span><br><span class="line">当onIdleCallback被执行时，当前时间减开始的event.timeStamp即为duration时间</span><br><span class="line"></span><br><span class="line">// 方式一</span><br><span class="line">function getFIDTime()&#123;</span><br><span class="line">    const timings = performance.getEntriesByType(&apos;first-input&apos;)[0];</span><br><span class="line">    return timings ? timings : null</span><br><span class="line">&#125;</span><br><span class="line">// 方式二，以下代码仅代表思路</span><br><span class="line"></span><br><span class="line">[&apos;click&apos;,&apos;touch&apos;,&apos;keydown&apos;].forEach(eventType =&gt; &#123;</span><br><span class="line">    window.addEventListener(eventType, eventHandle);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function eventHandle(e) &#123;</span><br><span class="line">    const eventTime = e.timeStamp;</span><br><span class="line">    window.requestIdleCallback(onIdleCallback.bind(this, eventTime, e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function onIdleCallback(eventTime, e) &#123;</span><br><span class="line">    const now = window.performance.now();</span><br><span class="line">    const duration = now - eventTime;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        duration: Math.round(duration),</span><br><span class="line">        timestamp: Math.round(eventTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [&apos;click&apos;,&apos;touch&apos;,&apos;keydown&apos;].forEach(eventType =&gt; &#123;</span><br><span class="line">        window.removeEventListener(eventType, eventHandle);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TTI"><a href="#TTI" class="headerlink" title="TTI"></a>TTI</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TTI，全称 Time To Interactive，翻译为可交互时间，指的是应用在视觉上都已渲染出了，完全可以响应用户的输入了</span><br><span class="line">是衡量应用加载所需时间并能够快速响应用户交互的指标</span><br><span class="line"></span><br><span class="line">统计方式一：谷歌实验室写的npm包，tti-polyfill</span><br></pre></td></tr></table></figure>
<h2 id="FCI"><a href="#FCI" class="headerlink" title="FCI"></a>FCI</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FCI，全称 First CPU Idle，翻译为首次CPU空闲时间代表着一个网页已经满足了最小程度的与用户发生交互行为的时刻</span><br><span class="line">当我们打开一个网页，我们并不需要等到一个网页完全加载好了</span><br><span class="line">每一个元素都已经完成了渲染，然后再去与网页进行交互行为</span><br><span class="line"></span><br><span class="line">网页满足了我们基本的交互的时间点是衡量网页性能的一个重要指标</span><br><span class="line"></span><br><span class="line">FCI为在FMP之后，首次在一定窗口时间内没有长任务发生的那一时刻，并且如果这个时间点早于DOMContentLoaded时间</span><br><span class="line">那么FCI的时间为DOMContentLoaded时间，窗口时间的计算函数</span><br><span class="line">可以根据Lighthouse提供的计算公式 N = f(t) = 4 * e^(-0.045 * t) + 1 进行自定义设计</span><br></pre></td></tr></table></figure>
<h2 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FPS，全称 Frames Per Second，翻译为每秒帧率，表示的是每秒钟画面更新次数，当今大多数设备的屏幕刷新率都是60次/秒</span><br><span class="line"></span><br><span class="line">帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；</span><br><span class="line">帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；</span><br><span class="line">帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；</span><br><span class="line">帧率波动很大的动画，亦会使人感觉到卡顿</span><br><span class="line"></span><br><span class="line">利用requestAnimationFrame,循环调用，当now大于lastTime+1S时，计算FPS</span><br><span class="line"></span><br><span class="line">若小于某个阀值则可以认为当前帧率较差，若连续小于多个阀值，则停止统计，当前页面处于卡顿状态，进入卡顿处理逻辑</span><br></pre></td></tr></table></figure>
<h2 id="Blink-内核早期架构"><a href="#Blink-内核早期架构" class="headerlink" title="Blink 内核早期架构"></a>Blink 内核早期架构</h2><p><img src="../images/render-irender-image.jpg" alt="渲染"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">以 Chrome 浏览器内核 Blink 渲染页面为例</span><br><span class="line">对早期的 Chrome 浏览器而言，每个页面 Tab 对应一个独立的 renderer 进程</span><br><span class="line">Renderer 进程中包含了主线程和合成线程</span><br><span class="line"></span><br><span class="line">主线程主要负责：</span><br><span class="line"></span><br><span class="line">Javascript 的计算与执行</span><br><span class="line">CSS 样式计算</span><br><span class="line">Layout 计算</span><br><span class="line">将页面元素绘制成位图（paint），也就是光栅化（Raster）</span><br><span class="line">将位图给合成线程</span><br><span class="line">合成线程则主要负责：</span><br><span class="line"></span><br><span class="line">将位图(GraphicsLayer 层)以纹理(texture)的形式上传给 GPU</span><br><span class="line">计算页面的可见部分和即将可见部分（滚动）</span><br><span class="line">CSS 动画处理</span><br><span class="line">通知 GPU 绘制位图到屏幕上</span><br><span class="line"></span><br><span class="line">JS 动画与 CSS 动画的细微区别</span><br><span class="line"></span><br><span class="line">对于 JS 动画而言，它们运行时的帧率即是主线程和合成线程加起来消耗的时间</span><br><span class="line">对于流畅动画而言，我们希望它们每一帧的耗时保持在 16.67ms 之内;</span><br><span class="line"></span><br><span class="line">而对于 CSS 动画而言，由于其流程不受主线程的影响，所以希望能得到合成线程的消耗的时间</span><br><span class="line">而合成线程的绘制频率也反映了滚动和 CSS 动画的流程性。</span><br><span class="line"></span><br><span class="line">上面主要想得出的一个结论是。如果我们能够知道主线程和合成线程每一帧消耗的时间</span><br><span class="line">那么我们就能大致得出对应的 Web 动画的帧率</span><br><span class="line">那么上面说到的 Frame Timing API 是否可以帮助我们拿到这个时间点呢</span><br><span class="line"></span><br><span class="line">所以 JS动画 性能不如 CSS动画</span><br></pre></td></tr></table></figure>
<h2 id="Frame-Timing-API"><a href="#Frame-Timing-API" class="headerlink" title="Frame Timing API"></a>Frame Timing API</h2><p><img src="../images/Web-Performance-Timing-API.png" alt="性能"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Frame Timing API 是 Web Performance Timing API 标准中的其中一位</span><br><span class="line"></span><br><span class="line">获取 Render 主线程和合成线程的记录，每条记录包含的信息</span><br><span class="line"></span><br><span class="line">var rendererEvents = window.performance.getEntriesByType(&quot;renderer&quot;);</span><br><span class="line">var compositeThreadEvents = window.performance.getEntriesByType(&quot;composite&quot;);</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">var observer = new PerformanceObserver(function(list) &#123;</span><br><span class="line">    var perfEntries = list.getEntries();</span><br><span class="line">    for (var i = 0; i &lt; perfEntries.length; i++) &#123;</span><br><span class="line">        console.log(&quot;frame: &quot;, perfEntries[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// subscribe to Frame Timing</span><br><span class="line">observer.observe(&#123;entryTypes: [&apos;frame&apos;]&#125;);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  sourceFrameNumber: 120,</span><br><span class="line">  startTime: 1342.549374253</span><br><span class="line">  cpuTime: 6.454313323</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">window.requestAnimationFrame(callback);</span><br><span class="line"></span><br><span class="line">告诉浏览器您希望执行动画并请求浏览器调用指定的函数在下一次重绘之前更新动画。</span><br><span class="line"></span><br><span class="line">当你准备好更新屏幕画面时你就应用此方法。这会要求你的动画函数在浏览器下次重绘前执行</span><br><span class="line">回调的次数常是每秒 60 次，大多数浏览器通常匹配 W3C 所建议的刷新率</span><br><span class="line"></span><br><span class="line">使用 requestAnimationFrame 计算 FPS 原理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var rAF = function () &#123;</span><br><span class="line">    return (</span><br><span class="line">        window.requestAnimationFrame ||</span><br><span class="line">        window.webkitRequestAnimationFrame ||</span><br><span class="line">        function (callback) &#123;</span><br><span class="line">            window.setTimeout(callback, 1000 / 60);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">var frame = 0;</span><br><span class="line">var allFrameCount = 0;</span><br><span class="line">var lastTime = Date.now();</span><br><span class="line">var lastFameTime = Date.now();</span><br><span class="line"></span><br><span class="line">var loop = function () &#123;</span><br><span class="line">    var now = Date.now();</span><br><span class="line">    var fs = (now - lastFameTime);</span><br><span class="line">    var fps = Math.round(1000 / fs);</span><br><span class="line"></span><br><span class="line">    lastFameTime = now;</span><br><span class="line">    // 不置 0，在动画的开头及结尾记录此值的差值算出 FPS</span><br><span class="line">    allFrameCount++;</span><br><span class="line">    frame++;</span><br><span class="line"></span><br><span class="line">    if (now &gt; 1000 + lastTime) &#123;</span><br><span class="line">        var fps = Math.round((frame * 1000) / (now - lastTime));</span><br><span class="line">        console.log(`$&#123;new Date()&#125; 1S内 FPS：`, fps);</span><br><span class="line">        frame = 0;</span><br><span class="line">        lastTime = now;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    rAF(loop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop();</span><br></pre></td></tr></table></figure>
<h2 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.navigator.userAgent中可以获取用户设备信息</span><br><span class="line"></span><br><span class="line">window.navigator.connection中可以获取设备网络信息</span><br><span class="line"></span><br><span class="line">window.devicePixelRatio中可以获取设备像素比</span><br></pre></td></tr></table></figure>
<h2 id="上报策略"><a href="#上报策略" class="headerlink" title="上报策略"></a>上报策略</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pv/uv     监听各种页面切换的情况；SPA页面，可以监听hashChange</span><br><span class="line"></span><br><span class="line">PV(page view)，即页面浏览量，或点击量；用户每1次对网站中的每个网页访问均被记录1次</span><br><span class="line">用户对同一页面的多次访问，访问量累计</span><br><span class="line"></span><br><span class="line">UV（独立访客）即Unique Visitor，访问您网站的一台电脑客户端为一个访客</span><br><span class="line"></span><br><span class="line">CV Content Views，内容播放数</span><br><span class="line"></span><br><span class="line">一个统计周期内，视频被打开，且视频正片内容（除广告）被成功播放的次数</span><br><span class="line"></span><br><span class="line">IP（独立IP）1天之内（00:00~24:00），访问网站的不重复的IP数</span><br><span class="line">拥有特定唯一IP的计算机访问网站的次数，因为这种统计方式比较容易实现，具有较高的真实性</span><br><span class="line"></span><br><span class="line">VV（video view，视频播放量）一个统计周期内，视频被打开的次数</span><br><span class="line"></span><br><span class="line">性能数据/设备信息/网络状况</span><br><span class="line"></span><br><span class="line">  在页面离开前上报 beforeUnload/visibilitychange/pagehide…+sendBeancon/Ajax</span><br><span class="line"></span><br><span class="line">  beforeUnload  事件</span><br><span class="line"></span><br><span class="line">  visibilitychange 事件  浏览器标签页被隐藏或显示的时候会触发</span><br><span class="line"></span><br><span class="line">  pagehide  pageshow 事件</span><br><span class="line"></span><br><span class="line">  navigator.sendBeacon() 方法  可用于通过HTTP将少量数据异步传输到Web服务器</span><br><span class="line">  sendBeacon() 方法会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能</span><br><span class="line">  这就解决了提交分析数据时的所有的问题：数据可靠，传输异步并且不会影响下一页面的加载。此外，代码实际上还要比其他技术简单许多</span><br><span class="line"></span><br><span class="line">  Ajax</span><br><span class="line"></span><br><span class="line">  img 标签+切片+压缩</span><br></pre></td></tr></table></figure>
<h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 使用window.onerror捕获JS运行时错误 有堆栈信息</span><br><span class="line"></span><br><span class="line">2. window.addEventListener(&apos;error&apos;)捕获资源加载错误。因为它也能捕获js运行时错误，为避免重复上报js运行时错误，此时只有event.srcElement inatanceof HTMLScriptElement或HTMLLinkElement或HTMLImageElement时才上报</span><br><span class="line"></span><br><span class="line">3. window.addEventListener(&apos;unhandledrejection&apos;)捕获未处理的promise reject错误</span><br><span class="line"></span><br><span class="line">4. 重写console.error捕获console.error错误</span><br><span class="line"></span><br><span class="line">5. 在跨域脚本上配置crossorigin=&quot;anonymous&quot;捕获跨域脚本错误</span><br><span class="line"></span><br><span class="line">6. 重写window.XMLHttpRequest和window.fetch捕获请求错误</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/08/facebook-css-trick/" rel="next" title="facebook css trick">
                <i class="fa fa-chevron-left"></i> facebook css trick
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/09/chrome-philosophy/" rel="prev" title="chrome philosophy">
                chrome philosophy <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">killsos.ql@gmail.com</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">137</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#FP"><span class="nav-number">1.</span> <span class="nav-text">FP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FCP"><span class="nav-number">2.</span> <span class="nav-text">FCP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MutationObserver"><span class="nav-number">3.</span> <span class="nav-text">MutationObserver</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FMP"><span class="nav-number">4.</span> <span class="nav-text">FMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FID"><span class="nav-number">5.</span> <span class="nav-text">FID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TTI"><span class="nav-number">6.</span> <span class="nav-text">TTI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FCI"><span class="nav-number">7.</span> <span class="nav-text">FCI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FPS"><span class="nav-number">8.</span> <span class="nav-text">FPS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Blink-内核早期架构"><span class="nav-number">9.</span> <span class="nav-text">Blink 内核早期架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Frame-Timing-API"><span class="nav-number">10.</span> <span class="nav-text">Frame Timing API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设备信息"><span class="nav-number">11.</span> <span class="nav-text">设备信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上报策略"><span class="nav-number">12.</span> <span class="nav-text">上报策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误信息"><span class="nav-number">13.</span> <span class="nav-text">错误信息</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">killsos.ql@gmail.com</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
